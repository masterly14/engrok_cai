generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                           String           @id @default(uuid()) @db.Uuid
  clerkId                      String           @unique
  email                        String           @unique
  name                         String?
  createdAt                    DateTime         @default(now())
  updatedAt                    DateTime         @default(now())
  amountCredits                Int
  totalConversations           Int              @default(0)
  totalAverageDuration         Int              @default(0)
  totalCost                    Int              @default(0)
  initialAmountCredits         Int              @default(1000)
  nangoConnectSessionExpiresAt DateTime?
  nangoConnectSessionToken     String?
  plan                         String?
  temporalVariantId            String?
  agents                       Agent[]
  chatAgents                   ChatAgent[]
  chatWorkflows                ChatWorkflow[]
  connections                  Connection[]
  integrations                 Integration[]
  knowledgeBases               KnowledgeBase[]
  leads                        Lead[]
  lsSubscriptions              LsSubscription[]
  phoneNumbers                 PhoneNumber[]
  stages                       Stage[]
  subscriptions                Subscription[]
  tags                         Tag[]
  transactions                 Transaction[]
  workflows                    Workflow[]
  accessTokens                 AccessToken[]
  creditLedgers                CreditLedger[]
  usageEvents                  UsageEvent[]
  workflowTriggers             WorkflowTrigger[]
  notifications                Notification[]
}

model UserAssets {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  type      String
  name      String
  url       String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Agent {
  id              String  @id @default(uuid()) @db.Uuid
  userId          String  @db.Uuid
  prompt          String
  name            String
  backgroundSound String?
  firstMessage    String
  vapiId          String? @unique
  voiceId         String?
  User            User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PhoneNumber {
  id              String   @id @default(uuid()) @db.Uuid
  provider        String
  number          String
  extension       String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  userId          String   @db.Uuid
  name            String?  @default("nuevo-numero")
  sipPassword     String?
  sipUri          String?
  sipUsername     String?
  twilioAccountId String?
  twilioAuthToken String?
  vapiId          String?  @unique @db.Uuid
  credentialId    String?  @db.Uuid
  assistantId     String?  @db.Uuid
  workflowId      String?  @db.Uuid
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ChatAgent {
  id                        String         @id @default(uuid()) @db.Uuid
  name                      String
  isActive                  Boolean        @default(false)
  createdAt                 DateTime       @default(now())
  updatedAt                 DateTime       @updatedAt
  userId                    String         @db.Uuid
  whatsappAccessToken       String
  whatsappBusinessAccountId String
  whatsappPhoneNumber       String
  whatsappPhoneNumberId     String         @unique
  user                      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatContacts              ChatContact[]
  chatSessions              ChatSession[]
  workflows                 ChatWorkflow[]
  messages                  Message[]
  messageTemplates          MessageTemplate[]
}

model MessageTemplate {
  id                 String           @id @default(uuid()) @db.Uuid
  name               String           /// nombre interno (único por agente + idioma)
  language           String           /// en_US, es_ES, …
  category           TemplateCategory
  status             TemplateStatus    @default(PENDING)    /// enum ya existente
  whatsappTemplateId String?          @unique               /// ID que devuelve la API
  components         Json             /// payload normalizado que envías a la API
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  /// Relación: cada plantilla pertenece a un ChatAgent
  agentId            String           @db.Uuid
  agent              ChatAgent        @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@unique([name, language, agentId])  /// evita duplicados por idioma/agente
}

model Workflow {
  id           String   @id @default(uuid()) @db.Uuid
  name         String
  vapiId       String?  @unique
  vapiWorkflowId String? @unique // ID del workflow en Vapi
  vapiWorkflowData Json? // Datos completos de la respuesta de Vapi
  tools        Json?
  workflowJson Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  userId       String   @db.Uuid
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ChatWorkflow {
  id        String        @id @default(uuid()) @db.Uuid
  name      String
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  agentId   String?       @db.Uuid
  workflow  Json
  userId    String?       @db.Uuid
  sessions  ChatSession[]
  agent     ChatAgent?    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  user      User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
  triggers  WorkflowTrigger[]

  @@unique([name, agentId, userId])
}

model ChatContact {
  phone       String        @unique
  name        String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  chatAgentId String        @db.Uuid
  id          String        @id @default(uuid()) @db.Uuid
  chatAgent   ChatAgent     @relation(fields: [chatAgentId], references: [id], onDelete: Cascade)
  sessions    ChatSession[]
  messages    Message[]
}

model ChatSession {
  id            String       @id @default(cuid())
  workflowId    String       @db.Uuid
  currentNodeId String
  status        SessionStatus @default(ACTIVE)
  variables     Json         @default("{}")
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  chatAgentId   String       @db.Uuid
  contactId     String       @db.Uuid
  chatAgent     ChatAgent    @relation(fields: [chatAgentId], references: [id], onDelete: Cascade)
  contact       ChatContact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  workflow      ChatWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@index([contactId, status])
}

model Connection {
  id                String   @id @default(uuid()) @db.Uuid
  connectionId      String
  providerConfigKey String?
  authMode          String
  endUserId         String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  userId            String   @db.Uuid
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model KnowledgeBase {
  id           String   @id @default(uuid()) @db.Uuid
  trieveApiKey String
  vapiId       String?  @unique
  name         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  userId       String   @db.Uuid
  credentialId String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Message {
  waId          String       @unique
  from          String
  to            String
  timestamp     DateTime
  type          MessageType
  textBody      String?
  metadata      Json?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  id            String       @id @default(uuid()) @db.Uuid
  chatAgentId   String       @db.Uuid
  chatContactId String?      @db.Uuid
  chatAgent     ChatAgent    @relation(fields: [chatAgentId], references: [id], onDelete: Cascade)
  chatContact   ChatContact? @relation(fields: [chatContactId], references: [id], onDelete: Cascade)

  @@index([from])
  @@index([timestamp])
  @@index([chatAgentId])
}

model Lead {
  id          String   @id @default(uuid())
  name        String
  company     String
  email       String
  phone       String
  status      String?
  tags        String[]
  lastContact String
  notes       String?
  value       Float?
  userId      String   @db.Uuid
  stageId     String
  stage       Stage    @relation(fields: [stageId, userId], references: [id, userId], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([stageId, userId])
}

model Stage {
  name   String
  color  String
  userId String @db.Uuid
  id     String
  leads  Lead[]
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([id, userId])
  @@unique([name, userId])
}

model Tag {
  name   String
  color  String
  userId String @db.Uuid
  id     String @id @default(uuid()) @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([name, userId])
}

model Call {
  id                  String    @id @default(uuid()) @db.Uuid
  vapiId              String?   @unique
  type                String
  orgId               String?
  createdAt           DateTime
  updatedAt           DateTime
  startedAt           DateTime?
  endedAt             DateTime?
  status              String
  endedReason         String?
  cost                Float?
  costBreakdown       Json?
  costs               Json[]
  phoneCallProvider   String?
  phoneCallTransport  String?
  phoneCallProviderId String?
  messages            Json[]
  assistantId         String?
  assistantOverrides  Json?
  squadId             String?
  workflowId          String?
  phoneNumberId       String?
  customerId          String?
  destination         Json?
  artifactPlan        Json?
  analysis            Json?
  monitor             Json?
  artifact            Json?
  schedulePlan        Json?
  transport           Json?
  name                String?

  @@map("calls")
}

model Subscription {
  id                 String  @id @default(uuid()) @db.Uuid
  planId             String  @db.Uuid
  status             String
  userId             String  @db.Uuid
  lemonSqueezyId     String  @unique
  email              String
  endsAt             String?
  isPaused           Boolean @default(false)
  isUsageBased       Boolean @default(false)
  name               String
  orderId            Int
  price              String
  renewsAt           String?
  statusFormatted    String
  subscriptionItemId String? @default(uuid())
  trialEndsAt        String?
  /// Créditos disponibles en el ciclo actual
  currentCredits     Int      @default(0)
  /// Fin del ciclo actual (próxima reposición de créditos)
  cycleEndAt         DateTime?
  plan               Plan    @relation(fields: [planId], references: [id], onDelete: Cascade)
  user               User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model Plan {
  id                 String         @id @default(uuid()) @db.Uuid
  name               String
  price              String
  interval           String?
  description        String?
  intervalCount      Int?
  isUsageBased       Boolean        @default(false)
  productId          Int
  productName        String?
  sort               Int?
  trialInterval      String?
  trialIntervalCount Int?
  /// Créditos asignados automáticamente a cada ciclo de facturación
  creditsPerCycle   Int            @default(0)
  /// Créditos que se descuentan por cada minuto de llamada de voz
  voiceCreditsPerMinute Int        @default(11)
  /// Créditos que se descuentan por cada conversación de WhatsApp (a partir de la 1001)
  chatCreditsPerConversation Int   @default(5)
  /// Precio USD por minuto excedente fuera de plan
  overageVoiceUsd   Float?         @default(0.17)
  /// Precio USD por conversación excedente fuera de plan
  overageChatUsd    Float?         @default(0.07)
  variantId          Int            @unique
  ui Json?
  subscriptions      Subscription[]
}

model Transaction {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  amount    Float
  type      String
  status    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Integration {
  id             String              @id @default(uuid()) @db.Uuid
  userId         String              @db.Uuid
  provider       IntegrationProvider
  status         IntegrationStatus   @default(ACTIVE)
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?
  scopes         String[]
  metadata       Json?
  lastSyncedAt   DateTime?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([provider])
  @@index([status])
}

/// ---------------------------------------------
/// Access Tokens for internal integrations (e.g., CRM webhook auth)
/// ---------------------------------------------

model AccessToken {
  id          String   @id @default(uuid()) @db.Uuid
  userId      String   @db.Uuid
  name        String   /// descriptive name, e.g. "crm-whatsapp-integration"
  accessToken String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
}

/// ---------------------------------------------
/// Lemon Squeezy – Subscription billing (SaaS)
/// ---------------------------------------------
model LsPlan {
  id            String           @id @default(uuid()) @db.Uuid
  storeId       Int
  productId     Int
  variantId     Int              @unique
  name          String
  /// price in cents
  price         Int
  interval      String?
  intervalCount Int?
  isUsageBased  Boolean          @default(false)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  subscriptions LsSubscription[]
}

model LsSubscription {
  id               String               @id @default(uuid()) @db.Uuid
  lsSubscriptionId Int                  @unique
  userId           String               @db.Uuid
  planId           String               @db.Uuid
  status           LsSubscriptionStatus
  renewsAt         DateTime?
  endsAt           DateTime?
  trialEndsAt      DateTime?
  isPaused         Boolean              @default(false)
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  plan             LsPlan               @relation(fields: [planId], references: [id], onDelete: Cascade)
  user             User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([planId])
}

model Credit {
  id     String @id @default(cuid())
  userId String
}

enum IntegrationProvider {
  FACEBOOK
  GOOGLE_CALENDAR
  GOOGLE_SHEETS
  CAL_COM
  HUBSPOT
  AIRTABLE
}

enum IntegrationStatus {
  ACTIVE
  INACTIVE
  ERROR
  PENDING
  EXPIRED
}

enum MessageType {
  TEXT
  IMAGE
  AUDIO
  VIDEO
  DOCUMENT
  LOCATION
  CONTACTS
  BUTTON
  INTERACTIVE
}

enum TYPE_AGENT {
  outbound
  inbound
  widget
}

enum TYPE_CHAT_AGENT {
  SALES
}

enum OrderStatus {
  PENDING
  APPROVED
  FAILED
  CANCELLED
}

enum SessionStatus {
  ACTIVE
  COMPLETED
  NEEDS_ATTENTION
}

enum TemplateStatus {
  PENDING
  APPROVED
  REJECTED
}

enum LsSubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELLED
  EXPIRED
  TRIALING
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @db.Uuid
  type      NotificationType
  read      Boolean          @default(false)
  message   String
  link      String?
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum NotificationType {
  HANDOVER_REQUEST
  BILLING_ISSUE
  TEMPLATE_APPROVED
}

/// ---------------------------------------------
/// Ledger de movimientos de créditos
/// ---------------------------------------------

model CreditLedger {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  delta     Int
  type      CreditLedgerType
  meta      Json?
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum CreditLedgerType {
  debit
  credit
  reset
  rollover
}

enum TemplateCategory {
  UTILITY
  MARKETING
  AUTHENTICATION
}

/// ---------------------------------------------
/// Registro de uso granular (voz, chat, etc.)
/// ---------------------------------------------

model UsageEvent {
  id             String    @id @default(uuid()) @db.Uuid
  userId         String    @db.Uuid
  kind           UsageKind
  quantity       Int
  creditsCharged Int
  externalRef    String?
  meta           Json?
  createdAt      DateTime  @default(now())

  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, kind])
}

enum UsageKind {
  voice
  chat
}

/// ---------------------------------------------
/// Triggers externos que enlazan integraciones (Sheets, HubSpot, etc.) con flujos de chat
/// ---------------------------------------------
model WorkflowTrigger {
  id           String   @id @default(uuid()) @db.Uuid
  token        String   @unique                           /// API token opcional para disparo manual
  userId       String   @db.Uuid                          /// Dueño del flujo / trigger
  workflowId   String   @db.Uuid                          /// Flujo que se disparará
  connectionId String?  @db.Uuid                          /// ConnectionId de Nango (nullable para Generic Webhook)
  syncName     String?                                    /// Nombre del sync en Nango (ej. "sheet-new-rows")
  provider     String                                     /// google-sheet | airtable | hubspot | webhook | ...
  mapping      Json                                       /// { phone:"phone", vars:{ name:"name" } }
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  workflow     ChatWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@index([provider])
  @@unique([workflowId, provider, connectionId])
}
